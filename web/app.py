""" Spotify Playground
    This application allows for advanced searching and discovery of music using Spotify's sophisticated recommendation engine.
"""

from flask import Flask, render_template, redirect, request, session
import requests
from access import CLIENT_ID, CLIENT_SECRET, REDIRECT_URI, SECRET_KEY, B64_CODE
from utils import get_id, get_genres, get_key_list, get_modes, get_user_id, create_playlist, add_songs_to_playlist, delete_playlist
from flask_wtf.csrf import CSRFProtect, CSRFError

# creates the CSRF protection object to be added to our app later
csrf = CSRFProtect()

# creates a Flask app
app = Flask(__name__)

# secret key and other secret data including CLIENT_ID, CLIENT_SECRET, B64_CODE stored with other constants in access.py
app.config['SECRET_KEY'] = SECRET_KEY

# enabling CSRF protection on our forms
csrf.init_app(app)



# ------------ROUTE TO ERROR HANDLER FOR CSRF-----------
@app.errorhandler(CSRFError)
def handle_csrf_error(e):
    """Redirects user to home page in the case of CSRF error including after 60 minutes of idle activity in search form"""
    
    return redirect('/')



# ------------ROUTE TO HOME PAGE------------
@app.route("/")
def get_homepage():
    """Shows homepage."""
    
    return render_template("index.html")



# ------------ROUTE TO APP LEVEL AUTHENTICATION WITH SPOTIFY------------
@app.route("/auth")
def get_spotify_auth():
    """Authenticates app with Spotify's API."""

    session.clear()
    
    # B64_CODE is an app level B64 encoded string generated by encoding CLIENT_ID:CLIENT_SECRET
    headers = {
        'Authorization':'Basic {}'.format(B64_CODE)
    }

    data = {
        'grant_type': 'client_credentials'
    }

    resp = requests.post('https://accounts.spotify.com/api/token', headers=headers, data=data).json()
    token = resp['access_token']
    session['token'] = token
    return redirect('/playground')



# ------------ROUTE FOR USER AUTHENTICATE AND AUTHORIZE WITH SPOTIFY------------
@app.route("/user_auth", methods=["GET"])
def get_spotify_user_auth():
    """Allows user to login to Spotify and this app"""
    try:
        session.pop('token', None)
        session.pop('refresh_token', None)
        session.pop('user_id', None)
        code = request.args.get('code')
        resp = requests.post('https://accounts.spotify.com/api/token', 
            data ={
                "grant_type": "authorization_code",
                "code": code,
                "redirect_uri": "http://localhost:5000/user_auth",
                "client_id": CLIENT_ID,
                "client_secret": CLIENT_SECRET
            }).json()
        token = resp['access_token']
        refresh_token = resp['refresh_token']
        session['token'] = token
        session['refresh_token'] = refresh_token
        session['user_id'] = get_user_id()
        return redirect('/playground')
    
    # A KeyError occurs if a user tries to access this route directly without having authenticated before
    except KeyError:
        return redirect('/')



# ------------ROUTE TO SEARCH PAGE------------
@app.route("/playground")
def go_to_search_page():
    """Sets up search page and redirect user there."""
    
    try:
        genres = get_genres()
        keys = get_key_list()
        modes = get_modes()
        return render_template("search.html", genres=genres, keys=keys, modes=modes)
    
    # A KeyError occurs if genres, keys, or modes aren't populated lists; these cannot be retrieved from the Spotify API unless authenticated
    except KeyError:
        return redirect('/')



# ------------ROUTE TO OUR API ENDPOINT FOR ARTIST OR TRACK SEARCH------------
@app.route("/search", methods=["GET"])
def artist_or_track_search():
    """API endpoint that accepts an artist or track query and type (artist or track) and returns a list of tuples with Spotify ID and artist or track name. [("Uesfsz...dsd","artist"),("TDSdsd...dfd","track")]."""
    try:
        artist = request.args.get('q')
        type = request.args.get('type')
        resp = get_id(artist,type)
        return resp
    
    except KeyError:
        return redirect('/') 
    


# ------------ROUTE TO GET SEED RESULTS------------
@app.route("/seed", methods=['POST'])
def show_recommendations():
    """Processes search data against Spotify's API and gets the user to this results page."""
    
    try:
        headers = {'Authorization':'Bearer ' + session['token']}
        payload = {}

        # gets a list of artists to be searched for, if any
        if request.form.get('artist'):
            artist_list = [f'{artist},' for artist in request.form.getlist('artist')]
            payload['seed_artists'] = artist_list

        # gets a list of tracks to be searched for, if any
        if request.form.get('track'):
            track_list = [f'{track},' for track in request.form.getlist('track')]
            payload['seed_tracks'] = track_list
        
        # gets the genre to be searched for, if any
        if request.form.get('seed_genre'):
            payload['seed_genres'] = request.form.get('seed_genre')

        # this series of seed inputs all aim to maximize that attribute (1.0 is 100%) but are 'target' values rather than 'maximum' values which would reduce the amount of results we get
        if request.form.get('acousticness'):
            payload['target_acousticness'] = 1.0
        if request.form.get('danceability'):
            payload['target_danceability'] = 1.0
        if request.form.get('energy'):
            payload['target_energy'] = 1.0
        if request.form.get('instrumentalness'):
            payload['target_instrumentalness'] = 1.0
        if request.form.get('liveness'):
            payload['target_liveness'] = 1.0
        if request.form.get('speechiness'):
            payload['target_speechiness'] = 1.0
        if request.form.get('valence'):
            payload['target_valence'] = 1.0

        # these seed inputs include either ranges or select fields
        if request.form.get('include_min_duration'):
            payload['min_duration_ms'] = int(request.form.get('min_duration'))
        if request.form.get('include_max_duration'):
            payload['max_duration_ms'] = int(request.form.get('max_duration'))
        if request.form.get('key'):
            payload['target_key'] = int(request.form.get('key'))
        if request.form.get('include_loudness'):
            payload['target_loudness'] = float(request.form.get('loudness'))
        if request.form.get('mode'):
            payload['target_mode'] = int(request.form.get('mode'))
        if request.form.get('include_popularity'):
            payload['target_popularity'] = int(request.form.get('popularity'))
        if request.form.get('include_tempo'):
            payload['target_tempo'] = float(request.form.get('tempo'))
        if request.form.get('include_time_sig'):
            payload['target_time_signature'] = int(request.form.get('time_sig'))

        resp = requests.get('https://api.spotify.com/v1/recommendations', params=payload, headers=headers).json()
        
        # used in the case of app level authentication
        track_id_list = []
        for track in resp['tracks']:
            track_id_list.append(track['id'])
        
        # used in the case of user level authentication
        track_uris = ""
        for track_uri in resp['tracks']:
            track_uris += track_uri['uri']+','
        
        # necessary in the case of app authentication as this data is necessary rendered in the returned template
        playlist_id = None
        
        if session.get('user_id'):
            session['playlist_id'] = create_playlist(session['user_id'])
            playlist_id = session['playlist_id']
            add_songs_to_playlist(session['playlist_id'], track_uris)
        
        return render_template("results.html", resp=resp, track_id_list=track_id_list, playlist_id=playlist_id)
    
    # a KeyError occurs when no artist, track, or genre is included in the seed search
    except KeyError:
        message = "Please enter at least an artist, song, or genre"
        genres = get_genres()
        keys = get_key_list()
        modes = get_modes()
        return render_template("search.html", genres=genres, keys=keys, modes=modes, message=message)



# ------------ROUTE TO DELETE SPOTIFY PLAYLIST------------
@app.route("/delete", methods=["GET"])
def remove_playlist():
    """Removes selected playlist from user's Spotify account"""
    try:
        delete_playlist(session['playlist_id'])
        message = "Playlist deleted from Spotify"
        genres = get_genres()
        keys = get_key_list()
        modes = get_modes()
        return render_template("search.html", genres=genres, keys=keys, modes=modes, message=message)

    except KeyError:
        redirect('/')


# ------------ROUTE TO LOGOUT FROM APP------------
@app.route("/logout")
def logout_user():
    """Clears all stored session data"""
    
    session.clear()
    return redirect('/')